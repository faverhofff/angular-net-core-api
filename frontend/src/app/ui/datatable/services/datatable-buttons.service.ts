import {Injectable} from "@angular/core";
import {HttpClient, HttpResponse} from "@angular/common/http";
import {LoadingService} from "../../../theme/services";
import {finalize} from "rxjs/internal/operators";
import {Observable} from "rxjs/index";
import {dataGet} from "../../../core/utils/utils";

declare const $: any;

@Injectable({
    providedIn: "root"
})

/**
 * Service used to request and download documents generated by datatables.
 *
 */
export class DatatableButtonsService {

    /**
     * @param {HttpClient} http
     * @param {LoadingService} loading
     */
    constructor(
        protected http: HttpClient,
        protected loading: LoadingService
    ) {}

    /**
     * Perform a button action. It starts all the process to download a document.
     * The parameters received are given from the button object.
     *
     * @param {Event} e
     * @param dt
     * @param button
     * @param config
     * @param {string} action
     */
    public execute(e: Event, dt: any, button: any, config: any, action: string): void {
        const url = `${dt.settings()[0].ajax.url}/export`;
        const params = dt.ajax.params();

        if (dataGet(config, 'exportOptions.columns', []).length > 0) {
            const exportOptionsColumns: Array<number> = dataGet(config, 'exportOptions.columns', []);

            //Deny export of all columns
            params['columns'].forEach((value) => {
                value['exportable'] = false;
            });

            //Grant export to columns defined in config
            exportOptionsColumns.forEach((value) => {
                if (dataGet(params, `columns.${value}`)) {
                    params['columns'][value]['exportable'] = true;
                }
            });
        }

        params.action = action;

        this.loading.start();

        this.download(url, params)
            .pipe(
                finalize(
                    () => this.loading.stop()
                )
            )
            .subscribe(this.processResponse);
    }

    /**
     * Create an observable to start a download.
     *
     * @param {string} url
     * @param {Partial<any>} params
     * @return {Observable<HttpResponse<Blob>>}
     */
    protected download(url: string, params: Partial<any> ): Observable<HttpResponse<Blob>> {
        const options = {};

        options['responseType'] = 'arraybuffer';
        options['headers'] = {
            'Content-type': 'application/x-www-form-urlencoded',
            'Accept': '*/*'
        };
        options['observe'] = 'response';

        return this.http.post<any>(url, $.param(params), options);
    }

    /**
     * Process the response from the download observer.
     *
     * @param {HttpResponse<Blob>} response
     */
    protected processResponse(response: HttpResponse<Blob>): void {
        let filename = "";
        const disposition = response.headers.get('content-disposition');
        if (disposition && disposition.indexOf('attachment') !== -1) {
            const filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
            const matches = filenameRegex.exec(disposition);
            if (matches != null && matches[1]) filename = matches[1].replace(/['"]/g, '');
        }

        const type = response.headers.get('content-type');

        const blob = new Blob([response.body], {type: type});
        if (typeof window.navigator.msSaveBlob !== 'undefined') {
            // IE workaround for "HTML7007: One or more blob URLs were revoked by closing the blob for which they were created. These URLs will no longer resolve as the data backing the URL has been freed."
            window.navigator.msSaveBlob(blob, filename);
        } else {
            const URL = window.URL || window['webkitURL'];
            const downloadUrl = URL.createObjectURL(blob);

            if (filename) {
                // use HTML5 a[download] attribute to specify filename
                const a = document.createElement("a");
                // safari doesn't support this yet
                if (typeof a.download === 'undefined') {
                    window['location'] = downloadUrl;
                } else {
                    a.href = downloadUrl;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                }
            } else {
                window['location'] = downloadUrl;
            }

            setTimeout(function () {
                URL.revokeObjectURL(downloadUrl);
            }, 100); // cleanup
        }
    }
}